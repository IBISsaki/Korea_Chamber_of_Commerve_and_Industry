아래는 String 클래스의 메모리 구조를 시각적으로 나타낸 그림입니다. 각 객체의 상태를 그림으로 표현하고, 
해당 객체의 메모리 구조와 연산 과정을 세부적으로 설명합니다.


1. String s2 = "hello";

Stack Memory:                       Heap Memory:

+------------+                      +---------+
| s2 (String)|                      |  Heap   |
+------------+                      +---------+
| str_  ----->|-------------------->| "hello" |  // s2의 str_이 가리키는 곳, 문자열 "hello"가 저장된 위치
| len_  5     |                      +---------+  // s2의 문자열 길이 저장 (널 종료 문자 포함되지 않음)
+------------+
    설명: s2 객체가 생성되며, "hello" 문자열이 동적 메모리에 할당됩니다. 
         str_ 포인터는 이 메모리 주소를 가리키고, len_은 문자열의 길이 5를 가집니다.


2. String s3 = s2;
Stack Memory:                       Heap Memory:

+------------+                      +---------+
| s3 (String)|                      |  Heap   |
+------------+                      +---------+
| str_  ----->|-------------------->| "hello" |  // s3의 str_이 가리키는 곳, s2의 문자열을 깊은 복사
| len_  5     |                      +---------+  // s3의 문자열 길이, s2와 동일한 5를 가짐
+------------+
    설명: s3는 s2의 복사 생성자로 생성되며, "hello" 문자열의 깊은 복사가 이루어집니다. 
         결과적으로 s3는 독립적인 메모리 공간을 가지며, str_은 새로 할당된 "hello"를 가리킵니다.


3. s1 = s3;

plaintext

Stack Memory:                       Heap Memory:

+------------+                      +---------+
| s1 (String)|                      |  Heap   |
+------------+                      +---------+
| str_  ----->|-------------------->| "hello" |  // s1의 str_이 가리키는 곳, s3의 문자열을 깊은 복사
| len_  5     |                      +---------+  // s1의 문자열 길이, s3와 동일한 5를 가짐
+------------+
    설명: s1은 s3의 깊은 복사로 초기화됩니다. 
         s1의 str_은 새로운 메모리 공간에 할당된 "hello" 문자열을 가리키고, len_은 5로 설정됩니다.


4. String s4 = ", world";

plaintext

Stack Memory:                       Heap Memory:

+------------+                      +-------------+
| s4 (String)|                      |    Heap     |
+------------+                      +-------------+
| str_  ----->|-------------------->| ", world"   |  // s4의 str_이 가리키는 곳, 문자열 ", world"가 저장된 위치
| len_  7     |                      +-------------+  // s4의 문자열 길이 저장, 7 (널 종료 문자 포함되지 않음)
+------------+
    설명: s4 객체가 생성되며, ", world" 문자열이 동적 메모리에 할당됩니다. 
         str_ 포인터는 이 메모리 주소를 가리키고, len_은 7로 설정됩니다.


5. s1 = s2 + s4;

plaintext

Stack Memory:                       Heap Memory:

+------------+                      +------------------+
| s1 (String)|                      |     Heap         |
+------------+                      +------------------+
| str_  ----->|-------------------->| "hello, world"   |  // s1의 str_이 가리키는 곳, s2와 s4의 문자열을 연결한 결과
| len_  13    |                      +------------------+  // s1의 새로운 문자열 길이 13 저장
+------------+

    설명: s1은 s2와 s4를 연결한 결과로 재할당됩니다. 
         "hello, world" 문자열이 새로 동적 메모리에 할당되고, str_ 포인터는 이 메모리 주소를 가리키며, 
         len_은 13으로 설정됩니다.


최종 메모리 구조 요약

plaintext

Stack Memory:                       Heap Memory:

+------------+                      +------------------+
| s2 (String)|                      | "hello"          |  // 초기 할당된 "hello" 메모리 (s2)
| str_  ----->|-------------------->| (len_ = 5)       |
+------------+                      +------------------+

+------------+                      +------------------+
| s3 (String)|                      | "hello"          |  // 깊은 복사된 "hello" 메모리 (s3)
| str_  ----->|-------------------->| (len_ = 5)       |
+------------+                      +------------------+

+------------+                      +------------------+
| s1 (String)|                      | "hello, world"   |  // 합쳐진 결과 "hello, world" 메모리 (s1)
| str_  ----->|-------------------->| (len_ = 13)      |
+------------+                      +------------------+

+------------+                      +------------------+
| s4 (String)|                      | ", world"        |  // 초기 할당된 ", world" 메모리 (s4)
| str_  ----->|-------------------->| (len_ = 7)       |
+------------+                      +------------------+

    s2, s3, s1(초기)는 모두 각각 별도의 "hello" 문자열을 가리키며, 서로 독립적인 메모리 블록에 존재합니다.
    s4는 ", world" 문자열을 가리키며, 마지막에 s2와 s4의 연결된 문자열 "hello, world"가 s1에 할당됩니다. 
    이 과정에서 메모리의 할당과 해제가 관리됩니다.

이 메모리 구조와 주석을 통해 코드가 어떻게 메모리를 관리하고 있는지 세부적으로 이해할 수 있습니다.
